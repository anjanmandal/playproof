import fs from "fs";
import path from "path";
import crypto from "crypto";
import { randomUUID } from "crypto";
import { prisma } from "../db/prisma";
import { mediaRoot } from "../config/storage";
import { buildSimplePdf } from "../utils/pdf";
import { EvidenceRequestBody, EvidenceResponse, EvidenceViewLogEntry } from "../types/evidence";
import { env } from "../config/env";

type EvidenceRecord = {
  filePath: string;
  athleteId: string;
  createdAt: number;
  expiresAt: number;
};

const evidenceStore = new Map<string, EvidenceRecord>();
const viewerStore = new Map<string, EvidenceViewLogEntry[]>();
const evidenceDir = path.join(mediaRoot, "evidence");
const SIGNING_SECRET = env.EVIDENCE_SECRET ?? env.JWT_SECRET ?? "evidence-secret";
const DOWNLOAD_WINDOW_MS = 15 * 60 * 1000;

const ensureEvidenceDir = async () => {
  await fs.promises.mkdir(evidenceDir, { recursive: true });
};

const hashSignature = (id: string, expires: number) =>
  crypto.createHmac("sha256", SIGNING_SECRET).update(`${id}:${expires}`).digest("hex");

export const generateEvidencePack = async (
  payload: EvidenceRequestBody,
  actor: { id: string; email: string },
): Promise<EvidenceResponse> => {
  if (!payload.athleteId) {
    throw new Error("athleteId is required");
  }
  await ensureEvidenceDir();
  const [athlete, rehab, risk, plan] = await Promise.all([
    prisma.athlete.findUnique({ where: { id: payload.athleteId } }),
    payload.rehabAssessmentId
      ? prisma.rehabAssessment.findUnique({ where: { id: payload.rehabAssessmentId } })
      : null,
    payload.riskSnapshotId
      ? prisma.riskSnapshot.findUnique({ where: { id: payload.riskSnapshotId } })
      : null,
    payload.planId ? prisma.teamPlan.findUnique({ where: { id: payload.planId } }) : null,
  ]);
  if (!athlete) {
    throw new Error("Athlete not found");
  }

  const sections: Array<{ heading: string; lines: string[] }> = [
    {
      heading: "Athlete",
      lines: [
        `Name: ${athlete.displayName ?? athlete.id}`,
        `Team: ${athlete.team ?? "N/A"}`,
        `Generated by: ${actor.email}`,
        `Generated at: ${new Date().toLocaleString()}`,
      ],
    },
  ];

  if (rehab) {
    sections.push({
      heading: "Rehab Summary",
      lines: [
        `Cleared: ${rehab.cleared ? "Yes" : "No"}`,
        `Limb symmetry: ${rehab.limbSymmetryScore.toFixed(1)}%`,
        `Concerns: ${rehab.concerns ?? "N/A"}`,
        `Notes: ${rehab.clinicianNotes ?? "N/A"}`,
      ],
    });
  }
  if (risk) {
    sections.push({
      heading: "Risk Snapshot",
      lines: [
        `Risk level: ${risk.riskLevel}`,
        `Change today: ${risk.changeToday ?? "N/A"}`,
        `Trend: ${risk.riskTrend ?? "N/A"}`,
      ],
    });
  }
  if (plan) {
    sections.push({
      heading: "Practice Plan",
      lines: [
        `Team: ${plan.team}`,
        `Session length: ${plan.sessionLength} min`,
        `Tweaks: ${Array.isArray(plan.selectedTweaks) ? plan.selectedTweaks.join(", ") : "N/A"}`,
      ],
    });
  }
  if (payload.notes) {
    sections.push({ heading: "Notes", lines: [payload.notes] });
  }

  const buffer = buildSimplePdf("Evidence Pack + Trust Receipt", sections);
  const evidenceId = randomUUID();
  const filePath = path.join(evidenceDir, `${evidenceId}.pdf`);
  await fs.promises.writeFile(filePath, buffer);
  const expiresAt = Date.now() + DOWNLOAD_WINDOW_MS;
  evidenceStore.set(evidenceId, {
    filePath,
    athleteId: payload.athleteId,
    createdAt: Date.now(),
    expiresAt,
  });
  viewerStore.set(evidenceId, []);
  const signature = hashSignature(evidenceId, expiresAt);
  const downloadUrl = `/evidence/pdf/${evidenceId}?expires=${expiresAt}&sig=${signature}`;
  return {
    evidenceId,
    downloadUrl,
    viewerLogUrl: `/evidence/pdf/${evidenceId}/views`,
    expiresAt: new Date(expiresAt).toISOString(),
  };
};

export const resolveEvidenceDownload = (id: string, sig: string, expires: number) => {
  const record = evidenceStore.get(id);
  if (!record) {
    throw new Error("Evidence not found");
  }
  if (Date.now() > expires || expires > record.expiresAt + DOWNLOAD_WINDOW_MS) {
    throw new Error("Link expired");
  }
  const expected = hashSignature(id, expires);
  if (sig !== expected) {
    throw new Error("Invalid signature");
  }
  return record.filePath;
};

export const logEvidenceView = (id: string, viewer: string) => {
  const log = viewerStore.get(id) ?? [];
  const entry: EvidenceViewLogEntry = {
    id: randomUUID(),
    viewer,
    viewedAt: new Date().toISOString(),
  };
  log.push(entry);
  viewerStore.set(id, log);
};

export const listEvidenceViews = (id: string): EvidenceViewLogEntry[] => viewerStore.get(id) ?? [];
